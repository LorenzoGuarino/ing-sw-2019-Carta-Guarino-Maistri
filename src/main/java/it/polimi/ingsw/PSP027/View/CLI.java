package it.polimi.ingsw.PSP027.View;

import it.polimi.ingsw.PSP027.Model.Game.GodCard;
import it.polimi.ingsw.PSP027.Network.Client.Client;
import it.polimi.ingsw.PSP027.Network.Client.ClientObserver;
import it.polimi.ingsw.PSP027.Network.Client.ServerObserver;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import java.util.*;
import java.util.concurrent.TimeUnit;

/**
 * @author Elisa Maistri
 */

public class CLI implements Runnable, ClientObserver {

    private Client client = null;
    private boolean bRun = false;
    private String cmdLine = "";
    private int requiredgods = 0;
    private List<String> gods = null;
    private boolean abortUserInput = false;
    private List<String> players = null;
    private Node nodeboard; //it's overwritten every time a new board needs to be printed
    private List<Integer> indexcandidatecells = new ArrayList<Integer>(); //used for move and build and is overwritten every time
    private String[] cellsToPrint = new String[25];
    private Map<String, String> NicknameColorMap = new HashMap<String, String>(); //maps the nickname to its assigned color for its workers on the board
    private Map<String, String> NicknameHighlightMap = new HashMap<String, String>();
    private Map<String, String> NicknameGodMap = new HashMap<String, String>();
    private String playersAndGods;
    private String playingPlayerNickname;
    private int chosenCellIndexRead;

    /* *********************************************************************************************************************
     * ************************************** UTILITY STRINGS FOR CLI RENDERING ****************************************** *
     * *********************************************************************************************************************/

    public static final String SANTORINI =
            "\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \n" +
                    "\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \n" +
                    "\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;25m▒\u001B[38;5;68;48;5;25m░\u001B[38;5;68;48;5;25m▒\u001B[38;5;32;48;5;60m▓\u001B[38;5;204;48;5;233m░\u001B[38;5;68;48;5;25m▒\u001B[38;5;68;48;5;25m░\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;204;48;5;233m░\u001B[38;5;68;48;5;25m▒\u001B[38;5;68;48;5;25m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;204;48;5;17m░\u001B[38;5;27;48;5;25m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;146;48;5;25m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;204;48;5;235m░\u001B[38;5;68;48;5;25m░\u001B[38;5;68;48;5;25m░\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \n" +
                    "\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;25m░\u001B[38;5;68;48;5;25m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;25m░\u001B[38;5;68;48;5;25m░\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;25m▒\u001B[38;5;68;48;5;25m▒\u001B[38;5;68;48;5;25m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;25m▒\u001B[38;5;68;48;5;25m▒\u001B[38;5;68;48;5;25m▒\u001B[38;5;68;48;5;25m▒\u001B[38;5;68;48;5;25m▒\u001B[38;5;68;48;5;25m▒\u001B[38;5;68;48;5;25m▒\u001B[38;5;68;48;5;25m▒\u001B[38;5;68;48;5;25m▒\u001B[38;5;68;48;5;25m▒\u001B[38;5;68;48;5;25m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;57;48;5;25m▒\u001B[38;5;68;48;5;25m▒\u001B[38;5;68;48;5;25m▒\u001B[38;5;68;48;5;25m▒\u001B[38;5;68;48;5;25m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;25m▒\u001B[38;5;68;48;5;25m▒\u001B[38;5;68;48;5;25m▒\u001B[38;5;68;48;5;25m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;25m▒\u001B[38;5;68;48;5;25m▒\u001B[38;5;68;48;5;25m░\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;56;48;5;25m▒\u001B[38;5;165;48;5;60m▓\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \n" +
                    "\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;25m▒\u001B[38;5;68;48;5;25m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;204;48;5;232m░\u001B[38;5;68;48;5;25m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;25m▒\u001B[38;5;26;48;5;61m░\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;25m▒\u001B[38;5;68;48;5;25m▒\u001B[38;5;1;48;5;16m \u001B[38;5;204;48;5;232m░\u001B[38;5;68;48;5;25m▒\u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;25m▒\u001B[38;5;68;48;5;25m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;69;48;5;61m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;88;48;5;232m░\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;47;48;5;25m░\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;25m▒\u001B[38;5;68;48;5;25m▒\u001B[38;5;204;48;5;232m░\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;25m▒\u001B[38;5;68;48;5;25m▒\u001B[38;5;68;48;5;25m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;54;48;5;20m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;25m▒\u001B[38;5;204;48;5;233m░\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;204;48;5;234m░\u001B[38;5;68;48;5;25m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;99;48;5;24m▒\u001B[38;5;68;48;5;25m▒\u001B[38;5;68;48;5;25m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;25m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;25m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \n" +
                    "\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;25m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;88;48;5;232m░\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;25m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;25m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;61;48;5;24m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;62;48;5;61m░\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;27;48;5;61m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;56;48;5;237m▓\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;4;48;5;61m░\u001B[38;5;68;48;5;61m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;196;48;5;60m░\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;204;48;5;17m░\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;25m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;61m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;84;48;5;61m░\u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;88;48;5;4m░\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;25m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \n" +
                    "\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;62m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;62m▒\u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;26;48;5;61m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;61m▒\u001B[38;5;186;48;5;61m▒\u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;1;48;5;16m░\u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \n" +
                    "\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;62m▒\u001B[38;5;68;48;5;62m▒\u001B[38;5;68;48;5;68m▒\u001B[38;5;69;48;5;67m▓\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;62m▒\u001B[38;5;68;48;5;68m▒\u001B[38;5;69;48;5;67m▓\u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;62m▒\u001B[38;5;68;48;5;68m▒\u001B[38;5;68;48;5;68m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;62m▒\u001B[38;5;68;48;5;62m▒\u001B[38;5;179;48;5;62m▓\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;62m▒\u001B[38;5;68;48;5;62m▒\u001B[38;5;68;48;5;62m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;62m▒\u001B[38;5;68;48;5;62m▒\u001B[38;5;68;48;5;62m▒\u001B[38;5;68;48;5;62m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;62m▒\u001B[38;5;88;48;5;233m░\u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;62m▒\u001B[38;5;68;48;5;62m▒\u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;68m▒\u001B[38;5;68;48;5;68m▒\u001B[38;5;68;48;5;62m▒\u001B[38;5;68;48;5;68m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;61m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;62m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;25;48;5;61m░\u001B[38;5;68;48;5;62m▒\u001B[38;5;68;48;5;68m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;61m▒\u001B[38;5;68;48;5;62m▒\u001B[38;5;68;48;5;62m▒\u001B[38;5;68;48;5;62m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;62m▒\u001B[38;5;68;48;5;62m▒\u001B[38;5;68;48;5;62m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \n" +
                    "\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;204;48;5;235m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;26;48;5;62m░\u001B[38;5;68;48;5;68m▒\u001B[38;5;68;48;5;68m▒\u001B[38;5;68;48;5;68m▒\u001B[38;5;68;48;5;68m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;68m▒\u001B[38;5;68;48;5;68m▒\u001B[38;5;69;48;5;68m▒\u001B[38;5;68;48;5;68m▒\u001B[38;5;68;48;5;68m▒\u001B[38;5;68;48;5;68m▒\u001B[38;5;68;48;5;68m▒\u001B[38;5;163;48;5;68m▓\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;68m▒\u001B[38;5;68;48;5;68m▒\u001B[38;5;68;48;5;68m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;68m▒\u001B[38;5;68;48;5;68m▒\u001B[38;5;68;48;5;68m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;175;48;5;236m▒\u001B[38;5;68;48;5;62m▒\u001B[38;5;68;48;5;62m▒\u001B[38;5;68;48;5;62m▒\u001B[38;5;1;48;5;16m \u001B[38;5;81;48;5;67m▓\u001B[38;5;68;48;5;68m▒\u001B[38;5;68;48;5;68m▒\u001B[38;5;68;48;5;68m▒\u001B[38;5;204;48;5;237m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;69;48;5;68m▒\u001B[38;5;1;48;5;16m \u001B[38;5;204;48;5;232m░\u001B[38;5;68;48;5;68m▒\u001B[38;5;68;48;5;68m▒\u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;68m▒\u001B[38;5;68;48;5;68m▒\u001B[38;5;68;48;5;68m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;68m▒\u001B[38;5;68;48;5;68m▒\u001B[38;5;68;48;5;68m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;68m▒\u001B[38;5;68;48;5;68m▒\u001B[38;5;1;48;5;4m░\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;98;48;5;67m▓\u001B[38;5;68;48;5;68m▒\u001B[38;5;68;48;5;68m▒\u001B[38;5;204;48;5;233m░\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;68m▒\u001B[38;5;68;48;5;68m▒\u001B[38;5;68;48;5;68m▒\u001B[38;5;68;48;5;68m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;68m▒\u001B[38;5;68;48;5;68m▒\u001B[38;5;68;48;5;68m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \n" +
                    "\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;69;48;5;238m▓\u001B[38;5;68;48;5;68m░\u001B[38;5;32;48;5;68m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;25;48;5;61m▒\u001B[38;5;68;48;5;68m▒\u001B[38;5;68;48;5;68m▒\u001B[38;5;68;48;5;68m▒\u001B[38;5;69;48;5;68m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;68m▒\u001B[38;5;68;48;5;68m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;68m▒\u001B[38;5;69;48;5;68m▒\u001B[38;5;68;48;5;68m▒\u001B[38;5;1;48;5;16m \u001B[38;5;167;48;5;233m░\u001B[38;5;68;48;5;68m▒\u001B[38;5;69;48;5;68m▒\u001B[38;5;68;48;5;68m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;68m▒\u001B[38;5;68;48;5;68m▒\u001B[38;5;68;48;5;68m▒\u001B[38;5;32;48;5;68m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;68m▒\u001B[38;5;68;48;5;68m▒\u001B[38;5;68;48;5;68m▒\u001B[38;5;68;48;5;68m▒\u001B[38;5;1;48;5;16m \u001B[38;5;55;48;5;68m▒\u001B[38;5;68;48;5;68m▒\u001B[38;5;68;48;5;68m▒\u001B[38;5;68;48;5;68m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;69;48;5;68m▒\u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;68m▒\u001B[38;5;67;48;5;61m▓\u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;68m▒\u001B[38;5;68;48;5;68m▒\u001B[38;5;25;48;5;61m░\u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;68m▒\u001B[38;5;69;48;5;68m▒\u001B[38;5;69;48;5;68m▒\u001B[38;5;1;48;5;16m░\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;68m▒\u001B[38;5;68;48;5;68m▒\u001B[38;5;69;48;5;68m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;68m▒\u001B[38;5;68;48;5;68m▒\u001B[38;5;62;48;5;31m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;45;48;5;244m▓\u001B[38;5;68;48;5;68m▒\u001B[38;5;68;48;5;68m▒\u001B[38;5;74;48;5;68m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;68m▒\u001B[38;5;68;48;5;68m▒\u001B[38;5;68;48;5;68m▒\u001B[38;5;68;48;5;68m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;204;48;5;16m░\u001B[38;5;68;48;5;68m▒\u001B[38;5;68;48;5;68m▒\u001B[38;5;68;48;5;68m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \n" +
                    "\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;75;48;5;68m░\u001B[38;5;68;48;5;68m░\u001B[38;5;68;48;5;68m░\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;68m░\u001B[38;5;69;48;5;68m░\u001B[38;5;69;48;5;68m░\u001B[38;5;69;48;5;68m░\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;68m░\u001B[38;5;69;48;5;68m░\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;68m░\u001B[38;5;68;48;5;68m░\u001B[38;5;69;48;5;68m░\u001B[38;5;68;48;5;68m░\u001B[38;5;1;48;5;16m \u001B[38;5;32;48;5;104m▓\u001B[38;5;68;48;5;68m░\u001B[38;5;68;48;5;68m░\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;68m▒\u001B[38;5;69;48;5;68m░\u001B[38;5;69;48;5;68m░\u001B[38;5;69;48;5;68m░\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;69;48;5;68m░\u001B[38;5;68;48;5;68m░\u001B[38;5;68;48;5;68m░\u001B[38;5;68;48;5;68m░\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;68m░\u001B[38;5;68;48;5;68m░\u001B[38;5;68;48;5;68m▒\u001B[38;5;5;48;5;6m \u001B[38;5;1;48;5;16m \u001B[38;5;204;48;5;237m▒\u001B[38;5;74;48;5;68m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;31;48;5;67m░\u001B[38;5;69;48;5;68m░\u001B[38;5;69;48;5;68m░\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;68m░\u001B[38;5;68;48;5;68m░\u001B[38;5;69;48;5;68m░\u001B[38;5;135;48;5;51m░\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;69;48;5;68m▒\u001B[38;5;69;48;5;68m░\u001B[38;5;68;48;5;68m░\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;68m░\u001B[38;5;68;48;5;68m░\u001B[38;5;68;48;5;68m░\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;204;48;5;16m░\u001B[38;5;68;48;5;68m▒\u001B[38;5;68;48;5;68m░\u001B[38;5;74;48;5;68m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;69;48;5;68m░\u001B[38;5;69;48;5;68m░\u001B[38;5;68;48;5;68m░\u001B[38;5;68;48;5;68m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;199;48;5;68m░\u001B[38;5;68;48;5;68m░\u001B[38;5;68;48;5;68m░\u001B[38;5;68;48;5;68m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \n" +
                    "\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;68m░\u001B[38;5;68;48;5;68m░\u001B[38;5;68;48;5;69m░\u001B[38;5;68;48;5;69m░\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;69m░\u001B[38;5;68;48;5;69m░\u001B[38;5;68;48;5;68m░\u001B[38;5;68;48;5;68m░\u001B[38;5;69;48;5;68m░\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;69;48;5;68m░\u001B[38;5;68;48;5;68m░\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;69;48;5;68m░\u001B[38;5;68;48;5;68m░\u001B[38;5;69;48;5;68m░\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;77;48;5;68m░\u001B[38;5;68;48;5;68m░\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;68m░\u001B[38;5;68;48;5;68m░\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;68m░\u001B[38;5;68;48;5;69m░\u001B[38;5;68;48;5;69m░\u001B[38;5;68;48;5;69m░\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;125;48;5;60m▓\u001B[38;5;69;48;5;68m░\u001B[38;5;68;48;5;68m░\u001B[38;5;68;48;5;68m░\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;32;48;5;68m▒\u001B[38;5;68;48;5;68m░\u001B[38;5;69;48;5;69m░\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;69;48;5;68m░\u001B[38;5;68;48;5;68m░\u001B[38;5;69;48;5;68m░\u001B[38;5;39;48;5;68m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;69;48;5;68m░\u001B[38;5;69;48;5;68m░\u001B[38;5;68;48;5;68m░\u001B[38;5;45;48;5;105m▓\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;69;48;5;68m░\u001B[38;5;68;48;5;68m░\u001B[38;5;68;48;5;68m░\u001B[38;5;68;48;5;68m░\u001B[38;5;1;48;5;16m \u001B[38;5;204;48;5;16m░\u001B[38;5;68;48;5;68m░\u001B[38;5;68;48;5;68m░\u001B[38;5;74;48;5;68m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;69m░\u001B[38;5;68;48;5;68m░\u001B[38;5;69;48;5;68m░\u001B[38;5;69;48;5;68m░\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;69;48;5;68m░\u001B[38;5;68;48;5;68m░\u001B[38;5;68;48;5;68m░\u001B[38;5;68;48;5;68m░\u001B[38;5;92;48;5;61m▓\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \n" +
                    "\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;68m░\u001B[38;5;68;48;5;69m░\u001B[38;5;68;48;5;69m░\u001B[38;5;111;48;5;69m░\u001B[38;5;111;48;5;105m░\u001B[38;5;111;48;5;105m░\u001B[38;5;111;48;5;105m░\u001B[38;5;68;48;5;69m░\u001B[38;5;68;48;5;69m░\u001B[38;5;68;48;5;69m░\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;69m░\u001B[38;5;68;48;5;69m░\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;69m░\u001B[38;5;69;48;5;69m░\u001B[38;5;68;48;5;69m░\u001B[38;5;68;48;5;68m░\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;69m░\u001B[38;5;68;48;5;69m░\u001B[38;5;68;48;5;69m░\u001B[38;5;68;48;5;69m░\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;68;48;5;69m░\u001B[38;5;68;48;5;69m░\u001B[38;5;68;48;5;105m░\u001B[38;5;68;48;5;69m░\u001B[38;5;68;48;5;69m░\u001B[38;5;69;48;5;69m░\u001B[38;5;204;48;5;233m░\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;198;48;5;238m▓\u001B[38;5;92;48;5;238m▓\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;69;48;5;68m░\u001B[38;5;69;48;5;68m░\u001B[38;5;68;48;5;68m░\u001B[38;5;204;48;5;233m░\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;69;48;5;68m░\u001B[38;5;68;48;5;68m░\u001B[38;5;204;48;5;234m░\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;111;48;5;69m░\u001B[38;5;69;48;5;69m░\u001B[38;5;69;48;5;69m░\u001B[38;5;69;48;5;69m░\u001B[38;5;99;48;5;51m░\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;168;48;5;238m▒\u001B[38;5;197;48;5;238m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \n" +
                    "\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;204;48;5;234m▒\u001B[38;5;111;48;5;69m░\u001B[38;5;62;48;5;68m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;167;48;5;234m▒\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;45;48;5;104m▒\u001B[38;5;204;48;5;233m░\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;88;48;5;232m░\u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \u001B[38;5;1;48;5;16m \n";

    public static final String TRIANGLE = "\u25b9";

    /* ******************************************************************************************************************************************************************* */

    public static final String DEFAULT_RESET = "\033[0m";  // Text Reset
    public static final String RESET = "\033[0;38;5;231;48;5;232m";
    public static final String SANTORINI_HIGHLIGHT = "\033[0;38;5;232;48;5;111m";
    public static final String SANTORINI_UNDERLINE = "\033[4;38;5;111;48;5;232m";
    public static final String SANTORINI_TEXT = "\033[0;38;5;111;48;5;232m";
    public static final String SANTORINI_WELCOME = "\033[3;1;38;5;111;48;5;232m";
    public static final String SANTORINI_BOLD = "\033[1;38;5;111;48;5;232m";
    public static final String DEFAULT_BOLD = "\033[1;97m";
    public static final String DEFAULT_ITALIC = "\033[3;97m";
    public static final String LINE = SANTORINI_UNDERLINE + "                                                                                                                                   " + RESET;
    public static final String WELCOME = SANTORINI_WELCOME + "Welcome to Santorini Game !" + RESET;
    public static final String AVAILABLECOMMANDS = "\n" + SANTORINI_HIGHLIGHT + " Available commands: " + RESET;
    public static final String COLOR_DOME = "\033[1;38;5;21;48;5;232m";
    public static final String COLOR_PLAYER_1 = "\033[38;5;198m";
    public static final String COLOR_PLAYER_2 = "\033[38;5;48m";
    public static final String COLOR_PLAYER_3 = "\033[38;5;45m";
    public static final String HIGHLIGHT_COLOR_PLAYER_1 = "\033[0;38;5;232;48;5;198m";
    public static final String HIGHLIGHT_COLOR_PLAYER_2 = "\033[0;38;5;232;48;5;48m";
    public static final String HIGHLIGHT_COLOR_PLAYER_3 = "\033[0;38;5;232;48;5;45m";
    public static final String ERROR_TEXT = "\033[0;38;5;196;48;5;232m";

    public void clearScreen() {
        System.out.print("\033[H\033[2J");
        System.out.print("\033[2J");
        System.out.flush();
    }

    /* ****************************************************** COMMANDS ************************************************** */

    private static String DISCONNECT_COMMAND = "disconnect";
    private static String BYE_COMMAND = "bye";
    private static String CONNECT_COMMAND = "connect";
    private static String REGISTER_COMMAND = "register";
    private static String DEREGISTER_COMMAND = "deregister";
    private static String SEARCHMATCH_COMMAND = "searchmatch";
    private static String CHOSENGODS_COMMAND = "chosengods";
    private static String CHOSENGOD_COMMAND = "chosengod";
    private static String CHOSENFIRSTPLAYER_COMMAND = "firstplayerchosen";
    private static String PLAY_COMMAND = "play";
    private static String WORKERSPOSITION_COMMAND = "workerspositionchosen";
    private static String CHOSENWORKER_COMMAND = "workerchosen";
    private static String CANDIDATECELLFORMOVE_COMMAND = "candidatecellchosen";
    private static String CANDIDATECELLFORBUILD_COMMAND = "candidatebuildcell";
    private static String CANDIDATECELLFOREND_COMMAND = "candidateendcell";
    private static String PASSMOVE_COMMAND = "movepassed";
    private static String PASSBUILD_COMMAND = "buildpassed";
    private static String PASSEND_COMMAND = "endpassed";

    /* ******************************************************** LABELS ***************************************************** */

    private static String DISCONNECT_COMMAND_LABEL = "  " + DEFAULT_BOLD + DISCONNECT_COMMAND + RESET + " (to disconnect from server)";
    private static String BYE_COMMAND_LABEL = "  " + DEFAULT_BOLD + BYE_COMMAND + RESET + " (to quit the game)";
    private static String CONNECT_COMMAND_LABEL = "  " + DEFAULT_BOLD + CONNECT_COMMAND + RESET + " ip:port (this will let you connect to Santorini server. Port is optional. If not specified the default value 2705 will be used)";
    private static String REGISTER_COMMAND_LABEL = "  " + DEFAULT_BOLD + REGISTER_COMMAND + " nickname" + RESET + " (to register yourself within Santorini game using given nickname)";
    private static String DEREGISTER_COMMAND_LABEL = "  " + DEFAULT_BOLD + DEREGISTER_COMMAND + RESET + " (to deregister yourself from Santorini game)";
    private static String PLAY_COMMAND_LABEL = "  " + DEFAULT_BOLD + PLAY_COMMAND + RESET + " (to start a new match)";
    private static String CONNECTED_LABEL = DEFAULT_ITALIC + "Successfully connected to server." + RESET + "\n";
    private static String DISCONNECTED_LABEL = "You are not actually connected to server.\n";
    private static String QUIT_GAME_LABEL = "Thank you for having played" + DEFAULT_BOLD + "Santorini" + RESET + "game.\n\nSee you soon!";
    private static String CHOOSE_MATCH_TYPE_LABEL = "\nPlease, enter the number of opponent players you wanna play with (choose between " + DEFAULT_BOLD + "1" + RESET + " or " + DEFAULT_BOLD + "2" + RESET + ")";
    private static String SEARCHING_MATCH_LABEL = DEFAULT_ITALIC + "\nSearching match ... please wait ..." + RESET;


    /* *********************************************************************************************************************** */

    private enum CLIConnectionState {
        cli_undetermined,
        cli_disconnected,
        cli_connecting,
        cli_Connected,
        cli_disconnecting,
    }

    private enum CLIGameState {
        cli_Deregistered,
        cli_Registering,
        cli_Registered,
        cli_Deregistering,
        cli_ChoosingMatch,
        cli_ChoosingGods,
        cli_ChoosingGod,
        cli_ChoosingFirstPlayer,
        cli_ChoosingWorkersStartPosition,
        cli_ManagePlacingFirstWorker,
        cli_ManagePlacingSecondWorker,
        cli_ChoosingWorker,
        cli_CandidateCellsForMove,
        cli_CandidateCellsForOptMove,
        cli_CandidateCellsForBuild,
        cli_ChooseBuildOrDome,
        cli_CandidateCellsForOptBuild,
        cli_CandidateCellsForOptEnd,
        cli_PrintingUpdatedBoard,
        cli_WaitForSomethingToHappen
    }

    /**
     * CLASS THAT MANAGES THE USER INPUT
     */

    private class Keyboardinput implements Runnable {

        private Scanner scanner = null;
        public boolean bRun = true;

        @Override
        public void run() {

            scanner = new Scanner(System.in);

            while (bRun) {
                cmdLine = scanner.nextLine();
            }
        }
    }

    private Keyboardinput kbinput = null;
    private CLIConnectionState connstate = CLIConnectionState.cli_undetermined;
    private CLIGameState gamestate = CLIGameState.cli_Deregistered;





    /**
     * Main method of the CLI which the user will run instantiating a new CLI
     *
     * @param args main arguments
     */

    public static void main(String[] args) {
        /* Instantiate a new CLI which will also receive events from
         * the server by implementing the ServerObserver interface */
        CLI cli = new CLI();
        cli.run();
    }




    /**
     * Method that checks if a command entered by the user is valid
     * @param command command to check
     * @return true if it's a valid command, otherwise false
     */

    public boolean IsAValidCommand(String command) {

        if (command.length() > 0) {
            String[] str = command.split(" ");

            if (str[0].equals("connect"))
                return true;
            if (str[0].equals("disconnect"))
                return true;
            if (str[0].equals("bye"))
                return true;
            if (str[0].equals("register"))
                return true;
            if (str[0].equals("deregister"))
                return true;
        }

        return false;
    }

    /**
     * Method used when waiting for a user input
     */

    private void WaitForUserInput() {
        try {
            abortUserInput = false;
            cmdLine = "";
            while (cmdLine.isEmpty() && !abortUserInput)
                TimeUnit.MILLISECONDS.sleep(10);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    /* ******************************************************************************************************************************** */

    /**
     * Method that is launched when the CLI starts and handles the action to perform in regard to the command entered by
     * by the user in an infinite cycle
     */

    @Override
    public void run() {
        //HEADER OF THE GAME
        System.out.println(SANTORINI);
        System.out.println(RESET);
        System.out.println(WELCOME);
        System.out.println(LINE);


        client = new Client();
        client.addObserver(this);
        // start thread to manage connection in background
        bRun = true;
        Thread clientThread = new Thread(client);
        clientThread.start();

        kbinput = new Keyboardinput();
        Thread kbinputThread = new Thread(kbinput);
        kbinputThread.start();

        String[] chosenposition = new String[2];

        while (bRun) {

            // SWITCH WHEN THE CONNECTION STATE CHANGES

            switch (connstate) {

                case cli_disconnected: {
                    System.out.println(AVAILABLECOMMANDS);
                    System.out.println(TRIANGLE + CONNECT_COMMAND_LABEL);
                    System.out.println(TRIANGLE + BYE_COMMAND_LABEL);

                    WaitForUserInput();

                    String[] cmdlineParts = cmdLine.split(" ");
                    if (cmdlineParts[0].equals(CONNECT_COMMAND)) {
                        connstate = CLIConnectionState.cli_connecting;
                        if (cmdlineParts.length == 2)
                            client.Connect(cmdlineParts[1]);
                        else
                            OnInvalidCommandSyntax(CONNECT_COMMAND);
                    } else if (cmdlineParts[0].equals(BYE_COMMAND)) {
                        client.Disconnect();
                        bRun = false;
                    }
                }
                break;

                case cli_connecting:
                case cli_disconnecting: {
                    System.out.print(".");
                    try {
                        TimeUnit.MILLISECONDS.sleep(50);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                break;

                case cli_Connected: {

                    // SWITCH WHEN THE GAME STATE CHANGES, ONLY POSSIBLE IN THE CONNECTED STATE

                    switch (gamestate) {
                        case cli_Deregistered: {
                            System.out.println(AVAILABLECOMMANDS);
                            System.out.println(TRIANGLE + REGISTER_COMMAND_LABEL);
                            System.out.println(TRIANGLE + DISCONNECT_COMMAND_LABEL);
                            System.out.println(TRIANGLE + BYE_COMMAND_LABEL);
                            WaitForUserInput();
                        }
                        break;

                        case cli_Registering:
                        case cli_Deregistering: {
                            System.out.print(".");
                            try {
                                TimeUnit.MILLISECONDS.sleep(50);
                            } catch (InterruptedException e) {
                                e.printStackTrace();
                            }
                        }
                        break;

                        case cli_Registered: {
                            System.out.println(AVAILABLECOMMANDS);
                            System.out.println(TRIANGLE + PLAY_COMMAND_LABEL);
                            System.out.println(TRIANGLE + DEREGISTER_COMMAND_LABEL);
                            System.out.println(TRIANGLE + DISCONNECT_COMMAND_LABEL);
                            System.out.println(TRIANGLE + BYE_COMMAND_LABEL);

                            WaitForUserInput();
                        }
                        break;

                        case cli_ChoosingMatch: {
                            System.out.println(CHOOSE_MATCH_TYPE_LABEL);
                            WaitForUserInput();
                            int players = Integer.parseInt(cmdLine);
                            if ((players >= 1) && (players <= 2)) {
                                // add local player to count as server search need to count all players...
                                players++;
                                System.out.println(SEARCHING_MATCH_LABEL);
                                // create an emulated command with proper syntax for
                                // processing entered command section
                                cmdLine = SEARCHMATCH_COMMAND + " " + Integer.toString(players);
                            }
                        }
                        break;

                        case cli_ChoosingGods: {
                            if (gods != null) {
                                clearScreen();
                                System.out.println("\n\nPlease choose " + DEFAULT_BOLD + Integer.toString(requiredgods) + RESET + " gods among the listed ones:");

                                for (int i = 0; i < gods.size(); i++) {
                                    System.out.println(TRIANGLE + " " + gods.get(i));
                                }

                                System.out.println("\nEnter a comma separated list of gods");
                                System.out.println("For a description of a god's power, enter \"help god's name\"");
                                WaitForUserInput();

                                String[] helpcmd = cmdLine.split(" ");
                                if (helpcmd[0].equals("help")) {
                                    System.out.println("\n");

                                    if (helpcmd.length == 2) {
                                        switch (helpcmd[1]) {
                                            case GodCard.APOLLO:
                                                System.out.println(GodCard.APOLLO_D);
                                                break;
                                            case GodCard.ARTEMIS:
                                                System.out.println(GodCard.ARTEMIS_D);
                                                break;
                                            case GodCard.ATHENA:
                                                System.out.println(GodCard.ATHENA_D);
                                                break;
                                            case GodCard.ATLAS:
                                                System.out.println(GodCard.ATLAS_D);
                                                break;
                                            case GodCard.DEMETER:
                                                System.out.println(GodCard.DEMETER_D);
                                                break;
                                            case GodCard.HEPHAESTUS:
                                                System.out.println(GodCard.HEPHAESTUS_D);
                                                break;
                                            case GodCard.MINOTAUR:
                                                System.out.println(GodCard.MINOTAUR_D);
                                                break;
                                            case GodCard.PAN:
                                                System.out.println(GodCard.PAN_D);
                                                break;
                                            case GodCard.PROMETHEUS:
                                                System.out.println(GodCard.PROMETHEUS_D);
                                                break;
                                            case GodCard.ZEUS:
                                                System.out.println(GodCard.ZEUS_D);
                                                break;
                                            case GodCard.HESTIA:
                                                System.out.println(GodCard.HESTIA_D);
                                                break;
                                            case GodCard.MEDUSA:
                                                System.out.println(GodCard.MEDUSA_D);
                                                break;
                                            case GodCard.ARES:
                                                System.out.println(GodCard.ARES_D);
                                                break;
                                            case GodCard.POSEIDON:
                                                System.out.println(GodCard.POSEIDON_D);
                                                break;
                                        }
                                        System.out.println("\n\n");
                                    }
                                } else {
                                    String[] chosengods = cmdLine.split(",");

                                    if (chosengods.length == requiredgods) {

                                        boolean bFound = false;

                                        for (String chosengod : chosengods) {
                                            chosengod = chosengod.trim();
                                            bFound = false;
                                            for (int i = 0; i < gods.size(); i++) {
                                                if (gods.get(i).equals(chosengod)) {
                                                    bFound = true;
                                                    break;
                                                }
                                            }
                                            if (bFound == false) {
                                                break;
                                            }

                                        }

                                        if (bFound == true) {
                                            // create an emulated command with proper syntax for
                                            // processing entered command section
                                            cmdLine = CHOSENGODS_COMMAND + " ";
                                            for (String chosengod : chosengods) {
                                                cmdLine += chosengod.trim() + " ";
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        break;

                        case cli_ChoosingGod: {
                            if (gods != null) {
                                clearScreen();
                                if (gods.size() > 1) {
                                    System.out.println("\nPlease choose your god from the listed ones:");
                                    for (int i = 0; i < gods.size(); i++) {
                                        System.out.println(TRIANGLE + " " + gods.get(i));
                                    }

                                    System.out.println("\nFor a description of a god's power, enter \"help god's name\"");
                                    WaitForUserInput();

                                    String[] helpcmd = cmdLine.split(" ");
                                    if (helpcmd[0].equals("help")) {
                                        if (helpcmd.length == 2) {
                                            switch (helpcmd[1]) {
                                                case GodCard.APOLLO:
                                                    System.out.println(GodCard.APOLLO_D);
                                                    break;
                                                case GodCard.ARTEMIS:
                                                    System.out.println(GodCard.ARTEMIS_D);
                                                    break;
                                                case GodCard.ATHENA:
                                                    System.out.println(GodCard.ATHENA_D);
                                                    break;
                                                case GodCard.ATLAS:
                                                    System.out.println(GodCard.ATLAS_D);
                                                    break;
                                                case GodCard.DEMETER:
                                                    System.out.println(GodCard.DEMETER_D);
                                                    break;
                                                case GodCard.HEPHAESTUS:
                                                    System.out.println(GodCard.HEPHAESTUS_D);
                                                    break;
                                                case GodCard.MINOTAUR:
                                                    System.out.println(GodCard.MINOTAUR_D);
                                                    break;
                                                case GodCard.PAN:
                                                    System.out.println(GodCard.PAN_D);
                                                    break;
                                                case GodCard.PROMETHEUS:
                                                    System.out.println(GodCard.PROMETHEUS_D);
                                                    break;
                                                case GodCard.ZEUS:
                                                    System.out.println(GodCard.ZEUS_D);
                                                    break;
                                                case GodCard.HESTIA:
                                                    System.out.println(GodCard.HESTIA_D);
                                                    break;
                                                case GodCard.MEDUSA:
                                                    System.out.println(GodCard.MEDUSA_D);
                                                    break;
                                                case GodCard.ARES:
                                                    System.out.println(GodCard.ARES_D);
                                                    break;
                                                case GodCard.POSEIDON:
                                                    System.out.println(GodCard.POSEIDON_D);
                                                    break;
                                            }
                                            System.out.println("\n\n");
                                        }
                                    } else {
                                        String chosengod = cmdLine;

                                        chosengod = chosengod.trim();
                                        boolean bFound = false;
                                        for (int i = 0; i < gods.size(); i++) {
                                            if (gods.get(i).equals(chosengod)) {
                                                bFound = true;
                                                break;
                                            }
                                        }
                                        if (bFound == false) {
                                            break;
                                        }

                                        if (bFound == true) {
                                            // create an emulated command with proper syntax for
                                            // processing entered command section
                                            cmdLine = CHOSENGOD_COMMAND + " " + chosengod;
                                        }

                                        System.out.println(DEFAULT_BOLD + "\nPlease wait while the others pick their gods." + RESET);
                                    }
                                } else {
                                    System.out.println("\nYour god is: " + gods.get(0));
                                    cmdLine = CHOSENGOD_COMMAND + " " + gods.get(0);
                                }
                            }
                        }
                        break;
                        case cli_ChoosingFirstPlayer: {
                            if (players != null) {
                                clearScreen();
                                System.out.println("\nPlease choose the player that will be the first one to place its workers on the board and then the first to play the game between the listed players:");
                                for (int i = 0; i < players.size(); i++) {
                                    System.out.println(players.get(i));
                                }

                                WaitForUserInput();

                                String chosenplayer = cmdLine;
                                chosenplayer = chosenplayer.trim();

                                boolean bFound = false;

                                for (String player : players) {
                                    if (player.equals(cmdLine)) {
                                        bFound = true;
                                        break;
                                    }
                                }

                                if (bFound == false) {
                                    break;
                                } else {
                                    // create an emulated command with proper syntax for
                                    // processing entered command section
                                    if(!cmdLine.equals(client.getNickname())){
                                        System.out.println(DEFAULT_BOLD + "\nPlease wait while the other players place their workers on the board" + RESET);
                                    }
                                    cmdLine = CHOSENFIRSTPLAYER_COMMAND + " " + chosenplayer;
                                }

                            }
                        }
                        break;

                        case cli_ChoosingWorkersStartPosition: {
                            clearScreen();

                            setCellsToPrint();

                            printBoard();

                            gamestate = CLIGameState.cli_ManagePlacingFirstWorker;

                        }
                        break;

                        case cli_ManagePlacingFirstWorker: {
                            System.out.println("\nPlease place your first worker on the board.\n" + DEFAULT_ITALIC + DEFAULT_BOLD +
                                    "Remember:" + RESET + DEFAULT_ITALIC + " You cannot put your workers in already occupied cells, which can be distinguished by" +
                                    "\ntheir different color corresponding to the color assigned to the player who owns those workers\n" + RESET +
                                    "Syntax to indicate the cells on which you want to place your worker: \"LetterNumber\"");

                            WaitForUserInput();

                            // process the user input regarding the 2 positions where the player wants to place its workers at the start of the game
                            String position = cmdLine.trim();

                            if (position.length() == 2) {

                                if (position.charAt(0) == 'A' || position.charAt(0) == 'B' || position.charAt(0) == 'C' || position.charAt(0) == 'D' || position.charAt(0) == 'E') {
                                    if (position.charAt(1) == '1' || position.charAt(1) == '2' || position.charAt(1) == '3' || position.charAt(1) == '4' || position.charAt(1) == '5') {

                                        int chosencellindex = (position.charAt(0) - 'A') * 5 + (position.charAt(1) - '1');

                                        //control that the position chosen was not occupied by another worker and is valid
                                        if(getNicknameOfCellNode(getCellNodeGivenTheID(chosencellindex)).isEmpty()) {
                                            chosenposition[0] = Integer.toString(chosencellindex);
                                            gamestate = CLIGameState.cli_ManagePlacingSecondWorker;
                                        }
                                    }
                                }
                            }
                        }
                        break;
                        
                        case cli_ManagePlacingSecondWorker: {
                            System.out.println("\nPlease place your second worker on the board.\n" + DEFAULT_ITALIC + DEFAULT_BOLD +
                                    "Remember:" + RESET + DEFAULT_ITALIC + " You cannot put your workers in already occupied cells, which can be distinguished by" +
                                    "\ntheir different color corresponding to the color assigned to the player who owns those workers\n" + RESET +
                                    "Syntax to indicate the cells on which you want to place your worker: \"LetterNumber\"");

                            WaitForUserInput();

                            // process the user input regarding the 2 positions where the player wants to place its workers at the start of the game
                            String position = cmdLine.trim();

                            if (position.length() == 2) {
                                if (position.charAt(0) == 'A' || position.charAt(0) == 'B' || position.charAt(0) == 'C' || position.charAt(0) == 'D' || position.charAt(0) == 'E') {
                                    if (position.charAt(1) == '1' || position.charAt(1) == '2' || position.charAt(1) == '3' || position.charAt(1) == '4' || position.charAt(1) == '5') {

                                        int chosencellindex;

                                        chosencellindex = (position.charAt(0) - 'A') * 5 + (position.charAt(1) - '1');

                                        //control that the position chosen was not occupied by another worker and is valid
                                        if(getNicknameOfCellNode(getCellNodeGivenTheID(chosencellindex)).isEmpty() && !chosenposition[0].equals(Integer.toString(chosencellindex))) {
                                            chosenposition[1] = Integer.toString(chosencellindex);

                                            cmdLine = WORKERSPOSITION_COMMAND + " " + chosenposition[0] + " " + chosenposition[1];

                                            System.out.println(DEFAULT_BOLD + "\nPlease wait for your turn to start.");

                                            gamestate = CLIGameState.cli_WaitForSomethingToHappen;
                                        }
                                    }
                                }
                            }
                        }
                        break;

                        case cli_ChoosingWorker:  {

                            clearScreen();

                            setCellsToPrint();

                            System.out.println("\n\n");
                            System.out.println(LINE);
                            printBoard();
                            System.out.println("\nPlease select the cell occupied by the worker you want to play with.\n" + DEFAULT_ITALIC + DEFAULT_BOLD +
                                    "Remember:" + RESET + DEFAULT_ITALIC + " You can only select workers of your own property, marked by your " + NicknameColorMap.get(client.getNickname()) + "color" +
                                    "\n" + RESET +
                                    "Syntax to indicate the cell occupied by the worker you want to select: \"LetterNumber\"");

                            WaitForUserInput();

                            String position = cmdLine.trim();

                            if (position.length() == 2) {
                                if (position.charAt(0) == 'A' || position.charAt(0) == 'B' || position.charAt(0) == 'C' || position.charAt(0) == 'D' || position.charAt(0) == 'E') {
                                    if (position.charAt(1) == '1' || position.charAt(1) == '2' || position.charAt(1) == '3' || position.charAt(1) == '4' || position.charAt(1) == '5') {

                                        int chosenCellIndex;

                                        chosenCellIndex = (position.charAt(0) - 'A') * 5 + (position.charAt(1) - '1');

                                        //control that the position chosen is occupied by one of the players workers
                                        if(getNicknameOfCellNode(getCellNodeGivenTheID(chosenCellIndex)).equals(client.getNickname())) {

                                            cmdLine = CHOSENWORKER_COMMAND + " " + chosenCellIndex;

                                            gamestate = CLIGameState.cli_WaitForSomethingToHappen;
                                        }
                                    }
                                }
                            }
                        }
                        break;

                        case cli_CandidateCellsForMove: {
                            clearScreen();

                            setCellsToPrint();

                            printBoard();
                            System.out.println("\nPlease select the cell you want to move on.\n" + DEFAULT_ITALIC + DEFAULT_BOLD +
                                    "Remember:" + RESET + DEFAULT_ITALIC + " You can only select the " + SANTORINI_HIGHLIGHT + " highlighted " + RESET +
                                    " cells, which, if your god allows you to move in a cell occupied by one of your opponent's workers, are highlighted with your opponent's color.\n" + "Syntax to indicate the cell you want to select: \"LetterNumber\"");

                            WaitForUserInput();

                            String position = cmdLine.trim();

                            if (position.length() == 2) {
                                if (position.charAt(0) == 'A' || position.charAt(0) == 'B' || position.charAt(0) == 'C' || position.charAt(0) == 'D' || position.charAt(0) == 'E') {
                                    if (position.charAt(1) == '1' || position.charAt(1) == '2' || position.charAt(1) == '3' || position.charAt(1) == '4' || position.charAt(1) == '5') {

                                        int chosenCellIndex;

                                        chosenCellIndex = (position.charAt(0) - 'A') * 5 + (position.charAt(1) - '1');

                                        //control that the cell chosen is one of the candidate cells

                                        for (int i = 0; i < indexcandidatecells.size(); i++) {
                                            if (indexcandidatecells.get(i) == chosenCellIndex) {

                                                cmdLine = CANDIDATECELLFORMOVE_COMMAND + " " + chosenCellIndex;

                                                gamestate = CLIGameState.cli_WaitForSomethingToHappen;

                                                restoreCandidateCells();
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        break;
                        case cli_CandidateCellsForOptMove: {
                            clearScreen();

                            setCellsToPrint();

                            printBoard();

                            System.out.println("\n" + DEFAULT_BOLD + "Your god allows you to move again." + RESET + "\nPlease select the cell you want to move on, or if you don't want to move again enter \"PASS\"\n" + DEFAULT_ITALIC + DEFAULT_BOLD +
                                    "Remember:" + RESET + DEFAULT_ITALIC + " You can only select the " + SANTORINI_HIGHLIGHT + " highlighted " + RESET +
                                    " cells, which, if your god allows you to move in a cell occupied by one of your opponent's workers, are highlighted with your opponent's color.\n" + "Syntax to indicate the cell you want to select: \"LetterNumber\"");

                            WaitForUserInput();

                            String position = cmdLine.trim();

                            if (position.length() == 2) {
                                if (position.charAt(0) == 'A' || position.charAt(0) == 'B' || position.charAt(0) == 'C' || position.charAt(0) == 'D' || position.charAt(0) == 'E') {
                                    if (position.charAt(1) == '1' || position.charAt(1) == '2' || position.charAt(1) == '3' || position.charAt(1) == '4' || position.charAt(1) == '5') {

                                        int chosenCellIndex;

                                        chosenCellIndex = (position.charAt(0) - 'A') * 5 + (position.charAt(1) - '1');

                                        //control that the cell chosen is one of the candidate cells

                                        for (int i = 0; i < indexcandidatecells.size(); i++) {
                                            if (indexcandidatecells.get(i) == chosenCellIndex) {

                                                cmdLine = CANDIDATECELLFORMOVE_COMMAND + " " + chosenCellIndex;

                                                gamestate = CLIGameState.cli_WaitForSomethingToHappen;

                                                restoreCandidateCells();
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                            else if(position.length() == 4 && position.equals("PASS")) {
                                cmdLine = PASSMOVE_COMMAND;
                                gamestate = CLIGameState.cli_WaitForSomethingToHappen;
                            }
                        }
                        break;
                        case cli_CandidateCellsForBuild: {
                            clearScreen();

                            setCellsToPrint();

                            printBoard();

                            System.out.println("\nPlease select the cell you want to build on.\n" + DEFAULT_ITALIC + DEFAULT_BOLD +
                                    "Remember:" + RESET + DEFAULT_ITALIC + " You can only select the " + SANTORINI_HIGHLIGHT + " highlighted " + RESET +
                                    " cells, including the ones highlighted with a player's color if your god allows to build where there's a player's worker on.\n" + "Syntax to indicate the cell you want to select: \"LetterNumber\"");

                            WaitForUserInput();

                            String position = cmdLine.trim();

                            if (position.length() == 2) {
                                if (position.charAt(0) == 'A' || position.charAt(0) == 'B' || position.charAt(0) == 'C' || position.charAt(0) == 'D' || position.charAt(0) == 'E') {
                                    if (position.charAt(1) == '1' || position.charAt(1) == '2' || position.charAt(1) == '3' || position.charAt(1) == '4' || position.charAt(1) == '5') {

                                        int chosenCellIndex;
                                        chosenCellIndex = (position.charAt(0) - 'A') * 5 + (position.charAt(1) - '1');
                                        chosenCellIndexRead = chosenCellIndex;

                                        //control that the cell chosen is one of the candidate cells

                                        for (int i = 0; i < indexcandidatecells.size(); i++) {
                                            if (indexcandidatecells.get(i) == chosenCellIndex) {

                                                if(NicknameGodMap.get(client.getNickname()).equals("Atlas")) {
                                                    gamestate = CLIGameState.cli_ChooseBuildOrDome;
                                                    break;
                                                }
                                                else {
                                                    cmdLine = CANDIDATECELLFORBUILD_COMMAND + " " + chosenCellIndex;
                                                    gamestate = CLIGameState.cli_WaitForSomethingToHappen;
                                                    restoreCandidateCells();
                                                    break;

                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        break;
                        case cli_ChooseBuildOrDome: {
                            System.out.println("\nPlease choose what you want to build: enter \"B\" if you want to build a standard block or \"D\" if you want to build a dome" + DEFAULT_ITALIC + DEFAULT_BOLD);

                            WaitForUserInput();

                            String build_BorD = cmdLine.trim();

                            if (build_BorD.length() == 1) {
                                if (build_BorD.equals("B") || build_BorD.equals("D")) {
                                    cmdLine = CANDIDATECELLFORBUILD_COMMAND +  " " + chosenCellIndexRead + " " + build_BorD;

                                    gamestate = CLIGameState.cli_WaitForSomethingToHappen;

                                    restoreCandidateCells();
                                    break;
                                }
                            }
                        }
                        break;
                        case cli_CandidateCellsForOptBuild: {
                            clearScreen();

                            setCellsToPrint();

                            printBoard();

                            if(NicknameGodMap.get(client.getNickname()).equals("Prometheus")) {
                                System.out.println("\n" + DEFAULT_BOLD + "Your god allows you to build before moving." + RESET + "\nPlease select the cell you want to build on, or if you don't want to build before moving, enter \"PASS\"\n" + DEFAULT_ITALIC + DEFAULT_BOLD +
                                        "Remember:" + RESET + DEFAULT_ITALIC + " You can only select the " + SANTORINI_HIGHLIGHT + " highlighted " + RESET +
                                        " cells, which, if your god allows you to build on a cell occupied by one of your opponent's workers, are highlighted with your opponent's color.\n" + "Syntax to indicate the cell you want to select: \"LetterNumber\"");
                            }
                            else {
                                System.out.println("\n" + DEFAULT_BOLD + "Your god allows you to build again." + RESET + "\nPlease select the cell you want to build on, or if you don't want to build again enter \"PASS\"\n" + DEFAULT_ITALIC + DEFAULT_BOLD +
                                        "Remember:" + RESET + DEFAULT_ITALIC + " You can only select the " + SANTORINI_HIGHLIGHT + " highlighted " + RESET +
                                        " cells, which, if your god allows you to build on a cell occupied by one of your opponent's workers, are highlighted with your opponent's color.\n" + "Syntax to indicate the cell you want to select: \"LetterNumber\"");
                            }

                            WaitForUserInput();

                            String position = cmdLine.trim();

                            if (position.length() == 2) {
                                if (position.charAt(0) == 'A' || position.charAt(0) == 'B' || position.charAt(0) == 'C' || position.charAt(0) == 'D' || position.charAt(0) == 'E') {
                                    if (position.charAt(1) == '1' || position.charAt(1) == '2' || position.charAt(1) == '3' || position.charAt(1) == '4' || position.charAt(1) == '5') {

                                        int chosenCellIndex;

                                        chosenCellIndex = (position.charAt(0) - 'A') * 5 + (position.charAt(1) - '1');

                                        //control that the cell chosen is one of the candidate cells

                                        for (int i = 0; i < indexcandidatecells.size(); i++) {
                                            if (indexcandidatecells.get(i) == chosenCellIndex) {

                                                cmdLine = CANDIDATECELLFORBUILD_COMMAND + " " + chosenCellIndex;

                                                gamestate = CLIGameState.cli_WaitForSomethingToHappen;

                                                restoreCandidateCells();
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                            else if(position.length() == 4 && position.equals("PASS")) {
                                cmdLine = PASSBUILD_COMMAND;
                                gamestate = CLIGameState.cli_WaitForSomethingToHappen;
                            }
                        }
                        break;

                        case cli_CandidateCellsForOptEnd: {
                            clearScreen();

                            setCellsToPrint();

                            printBoard();
                            System.out.println("\nPlease select the cell you want to perform your \"end of your turn\" action on, or if you don't want to, type \"PASS\".\n" + DEFAULT_ITALIC + DEFAULT_BOLD +
                                    "Remember:" + RESET + DEFAULT_ITALIC + " You can only select the " + SANTORINI_HIGHLIGHT + " highlighted " + RESET +
                                    "\n" + "Syntax to indicate the cell you want to select: \"LetterNumber\"");

                            WaitForUserInput();

                            String position = cmdLine.trim();

                            if (position.length() == 2) {
                                if (position.charAt(0) == 'A' || position.charAt(0) == 'B' || position.charAt(0) == 'C' || position.charAt(0) == 'D' || position.charAt(0) == 'E') {
                                    if (position.charAt(1) == '1' || position.charAt(1) == '2' || position.charAt(1) == '3' || position.charAt(1) == '4' || position.charAt(1) == '5') {

                                        int chosenCellIndex;

                                        chosenCellIndex = (position.charAt(0) - 'A') * 5 + (position.charAt(1) - '1');

                                        //control that the cell chosen is one of the candidate cells

                                        for (int i = 0; i < indexcandidatecells.size(); i++) {
                                            if (indexcandidatecells.get(i) == chosenCellIndex) {

                                                cmdLine = CANDIDATECELLFOREND_COMMAND + " " + chosenCellIndex;

                                                gamestate = CLIGameState.cli_WaitForSomethingToHappen;

                                                restoreCandidateCells();
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                            else if(position.length() == 4 && position.equals("PASS")) {
                                cmdLine = PASSEND_COMMAND;
                                restoreCandidateCells();
                                gamestate = CLIGameState.cli_WaitForSomethingToHappen;
                            }
                        }
                        break;

                        case cli_PrintingUpdatedBoard: {

                            clearScreen();
                            setCellsToPrint();
                            printBoard();
                            System.out.println("\n" + NicknameColorMap.get(playingPlayerNickname) + playingPlayerNickname + RESET + " is playing the turn, please wait.");

                            gamestate = CLIGameState.cli_WaitForSomethingToHappen;
                        }
                        break;

                        case cli_WaitForSomethingToHappen: {
                            // in this state user is allowed to enter commands on commandline
                            // which will be processed on switch exit
                            try {
                                TimeUnit.MILLISECONDS.sleep(50);
                            } catch (InterruptedException e) {
                                e.printStackTrace();
                            }
                        }
                        break;
                    }


                    // PROCESSING ENTERED COMMAND

                    if (!cmdLine.isEmpty()) {
                        String[] cmdlineParts = cmdLine.split(" ");

                        /* ************************** CONNECTION RELATED COMMANDS ********************** */

                        if (cmdlineParts[0].equals(DISCONNECT_COMMAND)) {
                            connstate = CLIConnectionState.cli_disconnecting;
                            client.Disconnect();
                        } else if (cmdlineParts[0].equals(BYE_COMMAND)) {
                            connstate = CLIConnectionState.cli_disconnecting;
                            client.Disconnect();
                            bRun = false;
                        } else if (cmdlineParts[0].equals(REGISTER_COMMAND)) {
                            if (cmdlineParts.length == 2) {
                                gamestate = CLIGameState.cli_Registering;
                                client.Register(cmdlineParts[1]);
                                //@TODO don't let users register with already taken nicknames
                            } else
                                OnInvalidCommandSyntax(REGISTER_COMMAND);
                        } else if (cmdlineParts[0].equals(DEREGISTER_COMMAND)) {
                            gamestate = CLIGameState.cli_Deregistering;
                            client.Deregister();
                        } else if (cmdlineParts[0].equals(PLAY_COMMAND)) {
                            gamestate = CLIGameState.cli_ChoosingMatch;
                        }

                        /* *************************** GAME RELATED COMMANDS *************************** */

                        else if (cmdlineParts[0].equals(SEARCHMATCH_COMMAND)) {
                            if (cmdlineParts.length == 2) {
                                gamestate = CLIGameState.cli_WaitForSomethingToHappen;
                                client.SearchMatch(Integer.parseInt(cmdlineParts[1]));
                            }
                        } else if (cmdlineParts[0].equals(CHOSENGODS_COMMAND)) {
                            if (cmdlineParts.length == (requiredgods + 1)) {
                                gamestate = CLIGameState.cli_WaitForSomethingToHappen;
                                List<String> chosengods = new ArrayList<String>();
                                for (int i = 1; i < (requiredgods + 1); i++) {
                                    chosengods.add(cmdlineParts[i]);
                                }
                                client.ChosenGods(chosengods);
                                System.out.println(DEFAULT_BOLD + "\nPlease wait while the other players choose their gods among the ones you picked..." + RESET);
                            }
                        } else if (cmdlineParts[0].equals(CHOSENGOD_COMMAND)) {
                            if (cmdlineParts.length == 2) {
                                gamestate = CLIGameState.cli_WaitForSomethingToHappen;
                                client.ChosenGod(cmdlineParts[1]);
                            }
                        } else if (cmdlineParts[0].equals(CHOSENFIRSTPLAYER_COMMAND)) {
                            if (cmdlineParts.length == 2) {
                                gamestate = CLIGameState.cli_WaitForSomethingToHappen;
                                client.ChosenFirstPlayer(cmdlineParts[1]);
                            }
                        } else if (cmdlineParts[0].equals(WORKERSPOSITION_COMMAND)) {
                            if (cmdlineParts.length == 3) {
                                gamestate = CLIGameState.cli_WaitForSomethingToHappen;
                                client.ChosenWorkersFirstPositions(cmdlineParts[1], cmdlineParts[2]);
                            }
                        } else if (cmdlineParts[0].equals(CHOSENWORKER_COMMAND)) {
                            if (cmdlineParts.length == 2) {
                                gamestate = CLIGameState.cli_WaitForSomethingToHappen;
                                client.ChosenWorker(cmdlineParts[1]);
                            }
                        } else if(cmdlineParts[0].equals(CANDIDATECELLFORMOVE_COMMAND)){
                            if (cmdlineParts.length == 2) {
                                gamestate = CLIGameState.cli_WaitForSomethingToHappen;
                                client.CandidateMove(cmdlineParts[1]);
                            }
                        } else if(cmdlineParts[0].equals(PASSMOVE_COMMAND)) {
                            if (cmdlineParts.length == 1) {
                                gamestate = CLIGameState.cli_WaitForSomethingToHappen;
                                client.passMove();
                            }
                        } else if(cmdlineParts[0].equals(CANDIDATECELLFORBUILD_COMMAND)) {
                            if (cmdlineParts.length == 2 || (cmdlineParts.length == 3 && NicknameGodMap.get(client.getNickname()).equals("Atlas"))) {
                                gamestate = CLIGameState.cli_WaitForSomethingToHappen;
                                if(NicknameGodMap.get(client.getNickname()).equals("Atlas")) {
                                    client.CandidateBuildForAtlas(cmdlineParts[1], cmdlineParts[2]);
                                }
                                else {
                                    client.CandidateBuild(cmdlineParts[1]);
                                }
                            }
                        } else if(cmdlineParts[0].equals(PASSBUILD_COMMAND)) {
                            if (cmdlineParts.length == 1) {
                                gamestate = CLIGameState.cli_WaitForSomethingToHappen;
                                client.passBuild();
                            }
                        } else if(cmdlineParts[0].equals(CANDIDATECELLFOREND_COMMAND)) {
                            if (cmdlineParts.length == 2) {
                                gamestate = CLIGameState.cli_WaitForSomethingToHappen;
                                client.CandidateEnd(cmdlineParts[1]);
                            }
                        } else if(cmdlineParts[0].equals(PASSEND_COMMAND)) {
                            if (cmdlineParts.length == 1) {
                                gamestate = CLIGameState.cli_WaitForSomethingToHappen;
                                client.passEnd();
                            }
                        }
                        cmdLine = "";
                    }
                }
                break;
            }
        }

        kbinput.bRun = false;

        System.out.println(QUIT_GAME_LABEL);
        System.exit(0);
    }

    /**
     * Method that tells the user why the command was invalid
     * @param cmd command that determines which error will be displayed to the user
     */

    public void OnInvalidCommandSyntax(String cmd) {
        if (cmd.equals("connect"))
            System.out.println(ERROR_TEXT + "\nMissing address from connect command.Syntax:\n connect ip:port where port is optional" + RESET);
        else if (cmd.equals("register"))
            System.out.println(ERROR_TEXT + "\nMissing nickname from register command. Syntax:\n register nickname\n" + RESET);
    }

    /* *********************************************************************************************************
     *       Methods fired by the client's methods that trigger a change of connection state or game state     *
     ***********************************************************************************************************/

    /**
     * Method of the ClientObserver interface that is fired by the client after connection
     */

    @Override
    public void OnConnected() {
        abortUserInput = true;
        System.out.println(CONNECTED_LABEL);
        connstate = CLIConnectionState.cli_Connected;
    }

    /**
     * Method of the ClientObserver interface that is fired by the client if there was an error when trying to connect
     */

    @Override
    public void OnConnectionError() {
        abortUserInput = true;
        System.out.println(DISCONNECTED_LABEL);
        connstate = CLIConnectionState.cli_disconnected;
        gamestate = CLIGameState.cli_Deregistered;
    }

    /**
     * Method of the ClientObserver interface that is fired by the client if it has been disconnected from the server
     */

    @Override
    public void OnDisconnected() {
        System.out.println(DISCONNECTED_LABEL);
        abortUserInput = true;
        gamestate = CLIGameState.cli_Deregistered;
        connstate = CLIConnectionState.cli_disconnected;
    }

    /**
     * Method of the ClientObserver interface that is fired by the client if the server connection was closed
     */

    @Override
    public void OnServerConnectionClosed() {
        System.out.println("\nserver connection closed");
    }

    /**
     * Method of the ClientObserver interface that is fired by the client if the server has died
     */

    @Override
    public void OnServerHasDied() {
        System.out.println("\nserver has died");
    }

    /**
     * Method of the ClientObserver interface that is fired by the client after the user has registered
     */

    @Override
    public void OnRegistered() {
        abortUserInput = true;
        gamestate = CLIGameState.cli_Registered;
        System.out.println(SANTORINI_BOLD + "Welcome " + client.getNickname() + "\n");
    }

    /**
     * Method of the ClientObserver interface that is fired by the client if there was an error when trying to register
     */

    @Override
    public void OnRegistrationError(String error) {
        gamestate = CLIGameState.cli_Deregistered;
        System.out.println("Registration failed: " + error);
    }

    /**
     * Method of the ClientObserver interface that is fired by the client after the user has been deregistered
     */

    @Override
    public void OnDeregistered() {
        abortUserInput = true;
        gamestate = CLIGameState.cli_Deregistered;
    }

    /**
     * Method of the ClientObserver interface that is fired by the client when a user leaves the match
     *
     * @param nickname nicknames of the user that left the match
     */

    @Override
    public void OnLeftMatch(String nickname) {
        System.out.println(nickname + " has left the game.");
    }

    /**
     * Method of the ClientObserver interface that is fired by the client after connection
     */
    @Override
    public void OnChooseMatchType() {
        abortUserInput = true;
        gamestate = CLIGameState.cli_ChoosingMatch;
    }

    /**
     * Method of the ClientObserver interface that is fired by the client when entering a match
     */

    @Override
    public void OnEnteringMatch(List<String> players) {
        System.out.println("\nEntering match. Current players:");

        for (String player : players) {
            System.out.println(TRIANGLE + " " + player);
        }

        System.out.println(DEFAULT_ITALIC + "\nWaiting for other players to join match" + RESET);
    }

    /**
     * Method of the ClientObserver interface that is fired by the client when it has entered a match
     */

    @Override
    public void OnEnteredMatch(List<String> players) {
        System.out.println("\n\nEntered match. Current players (with the assigned color that will be used to distinguish the workers' owner on the board):");

        boolean bMessage = false;
        for (int i = 0; i < players.size(); i++) {
            if (i == 0) {
                NicknameColorMap.put(players.get(i), COLOR_PLAYER_1);
                NicknameHighlightMap.put(players.get(i), HIGHLIGHT_COLOR_PLAYER_1);
                System.out.println(TRIANGLE + " " + COLOR_PLAYER_1 + players.get(i) + RESET);
            } else if (i == 1) {
                NicknameColorMap.put(players.get(i), COLOR_PLAYER_2);
                NicknameHighlightMap.put(players.get(i), HIGHLIGHT_COLOR_PLAYER_2);
                System.out.println(TRIANGLE + " " + COLOR_PLAYER_2 + players.get(i) + RESET);
                if(players.get(i).equals(client.getNickname())) {
                    bMessage = true;
                }
            } else if (i == 2) {
                NicknameColorMap.put(players.get(i), COLOR_PLAYER_3);
                NicknameHighlightMap.put(players.get(i), HIGHLIGHT_COLOR_PLAYER_3);
                System.out.println(TRIANGLE + " " + COLOR_PLAYER_3 + players.get(i) + RESET);
                if(players.get(i).equals(client.getNickname())) {
                    bMessage = true;
                }
            }

        }

        if(bMessage) {
            System.out.println("\n" + DEFAULT_BOLD + "Wait while the master player (" + COLOR_PLAYER_1 + players.get(0) + RESET + DEFAULT_BOLD + ") chooses the gods you will play with." + RESET);
        }


    }

    /**
     * Method of the ClientObserver interface that is fired by the client when choosing the list of gods to use in the match
     *
     * @param requiredgods number of gods that the client must choose
     * @param gods         gods' names chosen by the user
     */

    @Override
    public void OnChooseGods(int requiredgods, List<String> gods) {
        abortUserInput = true;
        gamestate = CLIGameState.cli_ChoosingGods;
        this.requiredgods = requiredgods;
        this.gods = gods;
    }

    /**
     * Method of the ClientObserver interface that is fired by the client when choosing the god to play with
     *
     * @param chosengods chosen gods to set as the gods managed by the cli that will communicate them to the user
     */

    @Override
    public void OnChooseGod(List<String> chosengods) {
        abortUserInput = true;
        gamestate = CLIGameState.cli_ChoosingGod;
        this.gods = chosengods;
    }

    /**
     * Method of the ClientObserver interface that is fired by the client when choosing the first player that
     * will place its workers and start playing
     *
     * @param players players in the match from which the selection must be done
     */

    @Override
    public void OnChooseFirstPlayer(List<String> players) {
        abortUserInput = true;
        gamestate = CLIGameState.cli_ChoosingFirstPlayer;
        this.players = players;
    }


    /**
     * Method of the ClientObserver interface that is fired by the client when placing the workers on the board for the first time
     * @param nodes board in xml format that needs to be processed by the CLI when it prints the board
     * it also contains the list of players with their gods that needs to be saved
     */

    @Override
    public void OnChooseWorkerStartPosition(NodeList nodes) {
        abortUserInput = true;
        gamestate = CLIGameState.cli_ChoosingWorkersStartPosition;

        Node node;
        for (int i = 0; i < nodes.getLength(); i++) {
            node = nodes.item(i);

            if (node.getNodeName().equals("board")) {
                this.nodeboard = node;
            }
            else if (node.getNodeName().equals("players")) {

                Node player;
                if (node.hasChildNodes()) {
                    NodeList players = node.getChildNodes();

                    for (int j = 0; j < players.getLength(); j++) {
                        player = players.item(j);

                        if (player.getNodeName().equals("player")) {
                            String playerNickname = player.getAttributes().getNamedItem("nickname").getTextContent();
                            String playerGod = player.getAttributes().getNamedItem("god").getTextContent();

                            NicknameGodMap.put(playerNickname, playerGod);
                        }
                    }
                }
            }
        }
    }


    /* ************************************* METHODS REGARDING THE COMMUNICATION WHEN THE TURN HAS STARTED ************************+ */

    /**
     * Method of the ClientObserver interface that is fired by the client when choosing the worker to play the turn with
     * @param board board in xml format that needs to be processed by the CLI when it prints the board
     */

    @Override
    public void OnChooseWorker(Node board) {
        abortUserInput = true;
        gamestate = CLIGameState.cli_ChoosingWorker;
        this.nodeboard = board;
    }

    /**
     * Method of the ClientObserver interface that is fired by the client when choosing the cell to move the worker onto
     * @param nodes cells where is possible to move the worker in xml format that needs to be processed by the CLI
     */
    @Override
    public void OnCandidateCellsForMove(NodeList nodes) {
        abortUserInput = true;
        gamestate = CLIGameState.cli_CandidateCellsForMove;

        indexcandidatecells.clear();
        Node node;
        for (int i = 0; i < nodes.getLength(); i++) {
            node = nodes.item(i);

            if (node.getNodeName().equals("board")) {
                this.nodeboard = node;
            }
            else if (node.getNodeName().equals("candidates")) {

                Node cell;
                if (node.hasChildNodes()) {
                    NodeList cells = node.getChildNodes();

                    for (int j = 0; j < cells.getLength(); j++) {
                        cell = cells.item(j);

                        if (cell.getNodeName().equals("cell")) {
                            int id = getIdOfCellNode(cell);
                            indexcandidatecells.add(id);
                        }
                    }
                }
            }
        }
    }

    /**
     * Method of the ClientObserver interface that is fired by the client when choosing the cell to move the worker onto
     * @param nodes cells where is possible to move the worker in xml format that needs to be processed by the CLI
     */
    @Override
    public void OnCandidateCellsForOptMove(NodeList nodes) {
        abortUserInput = true;
        gamestate = CLIGameState.cli_CandidateCellsForOptMove;

        indexcandidatecells.clear();
        Node node;
        for (int i = 0; i < nodes.getLength(); i++) {
            node = nodes.item(i);

            if (node.getNodeName().equals("board")) {
                this.nodeboard = node;
            }
            else if (node.getNodeName().equals("candidates")) {

                Node cell;
                if (node.hasChildNodes()) {
                    NodeList cells = node.getChildNodes();

                    for (int j = 0; j < cells.getLength(); j++) {
                        cell = cells.item(j);

                        if (cell.getNodeName().equals("cell")) {
                            int id = getIdOfCellNode(cell);
                            indexcandidatecells.add(id);
                        }
                    }
                }
            }
        }
    }

    /**
     * Method of the ClientObserver interface that is fired by the client when choosing the cell to move the worker onto
     * @param nodes cells where is possible to move the worker in xml format that needs to be processed by the CLI
     */
    @Override
    public void OnCandidateCellsForBuild(NodeList nodes) {
        abortUserInput = true;
        gamestate = CLIGameState.cli_CandidateCellsForBuild;

        indexcandidatecells.clear();
        Node node;
        for (int i = 0; i < nodes.getLength(); i++) {
            node = nodes.item(i);

            if (node.getNodeName().equals("board")) {
                this.nodeboard = node;
            }
            else if (node.getNodeName().equals("candidates")) {

                Node cell;
                if (node.hasChildNodes()) {
                    NodeList cells = node.getChildNodes();

                    for (int j = 0; j < cells.getLength(); j++) {
                        cell = cells.item(j);

                        if (cell.getNodeName().equals("cell")) {
                            int id = getIdOfCellNode(cell);
                            indexcandidatecells.add(id);
                        }
                    }
                }
            }
        }
    }

    /**
     * Method of the ClientObserver interface that is fired by the client when choosing the cell to move the worker onto
     * @param nodes cells where is possible to move the worker in xml format that needs to be processed by the CLI
     */
    @Override
    public void OnCandidateCellsForOptBuild(NodeList nodes) {
        abortUserInput = true;
        gamestate = CLIGameState.cli_CandidateCellsForOptBuild;

        indexcandidatecells.clear();
        Node node;
        for (int i = 0; i < nodes.getLength(); i++) {
            node = nodes.item(i);

            if (node.getNodeName().equals("board")) {
                this.nodeboard = node;
            }
            else if (node.getNodeName().equals("candidates")) {

                Node cell;
                if (node.hasChildNodes()) {
                    NodeList cells = node.getChildNodes();

                    for (int j = 0; j < cells.getLength(); j++) {
                        cell = cells.item(j);

                        if (cell.getNodeName().equals("cell")) {
                            int id = getIdOfCellNode(cell);
                            indexcandidatecells.add(id);
                        }
                    }
                }
            }
        }
    }

    /**
     * Method of the ClientObserver interface that is fired by the client when choosing the cell to move the worker onto
     * @param nodes cells where is possible to move the worker in xml format that needs to be processed by the CLI
     */
    @Override
    public void OnCandidateCellsForOptEnd(NodeList nodes) {
        abortUserInput = true;
        gamestate = CLIGameState.cli_CandidateCellsForOptEnd;

        indexcandidatecells.clear();
        Node node;
        for (int i = 0; i < nodes.getLength(); i++) {
            node = nodes.item(i);

            if (node.getNodeName().equals("board")) {
                this.nodeboard = node;
            }
            else if (node.getNodeName().equals("candidates")) {

                Node cell;
                if (node.hasChildNodes()) {
                    NodeList cells = node.getChildNodes();

                    for (int j = 0; j < cells.getLength(); j++) {
                        cell = cells.item(j);

                        if (cell.getNodeName().equals("cell")) {
                            int id = getIdOfCellNode(cell);
                            indexcandidatecells.add(id);
                        }
                    }
                }
            }
        }
    }

    /**
     * Method of the ClientObserver interface that is fired by the client when there's a winner
     *
     * @param nickname nickname of the winner
     */

    @Override
    public void OnWinner(String nickname) {
        if (client.getNickname().equals(nickname))
            System.out.println(SANTORINI_BOLD + "\n\nYou have won the game. Congrats !!" + RESET);
        else
            System.out.println("\n\n" + DEFAULT_BOLD + nickname + " has won the game." + RESET);

        if(gods != null) {
            gods.clear();
        }
        if(players != null) {
            players.clear();
        }
        indexcandidatecells.clear();
        NicknameColorMap.clear();
        NicknameHighlightMap.clear();
        NicknameGodMap.clear();
        playersAndGods = "";
        playingPlayerNickname = "";

        System.out.println(AVAILABLECOMMANDS);
        System.out.println(TRIANGLE + PLAY_COMMAND_LABEL);
        System.out.println(TRIANGLE + DEREGISTER_COMMAND_LABEL);
        System.out.println(TRIANGLE + DISCONNECT_COMMAND_LABEL);
        System.out.println(TRIANGLE + BYE_COMMAND_LABEL);
    }

    /**
     * Method of the ClientObserver interface that is fired by the client when a user loses
     */

    @Override
    public void OnLoser() {
        System.out.println(DEFAULT_BOLD + "\n\nYou have lost! Better luck next time.\n" + RESET);

        if(gods != null) {
            gods.clear();
        }
        if(players != null) {
            players.clear();
        }
        indexcandidatecells.clear();
        NicknameColorMap.clear();
        NicknameHighlightMap.clear();
        NicknameGodMap.clear();
        playersAndGods = "";
        playingPlayerNickname = "";


        System.out.println(AVAILABLECOMMANDS);
        System.out.println(TRIANGLE + PLAY_COMMAND_LABEL);
        System.out.println(TRIANGLE + DEREGISTER_COMMAND_LABEL);
        System.out.println(TRIANGLE + DISCONNECT_COMMAND_LABEL);
        System.out.println(TRIANGLE + BYE_COMMAND_LABEL);
    }


    /**
     * Method of the ClientObserver interface that is fired by the client when receiving the updated board when it's not playing
     * @param nodes board cells updated and the playing player's nickname
     */
    @Override
    public void OnPrintUpdatedBoard(NodeList nodes) {
        abortUserInput = true;
        gamestate = CLIGameState.cli_PrintingUpdatedBoard;

        Node node;
        for (int i = 0; i < nodes.getLength(); i++) {
            node = nodes.item(i);

            if (node.getNodeName().equals("board")) {
                this.nodeboard = node;
            }
            else if (node.getNodeName().equals("playingPlayer")) {

                this.playingPlayerNickname = node.getAttributes().getNamedItem("nickname").getTextContent();

            }
        }
    }



    /* ******************************************************************************************************* *
     *                            UTILITY METHODS FOR MANAGING THE BOARD TO PRINT                              *
     * ******************************************************************************************************* */

    /**
     * Method that returns the node of the cell that has a certain id from the board in xml format (nodeboard of the class)
     * @param cellnodeid is of the cell node that is being found
     * @return the cell node found with the given id, null if there were no cells in the board given by the server
     */

    public Node getCellNodeGivenTheID(int cellnodeid) {
        Node cell;

        if (nodeboard.hasChildNodes()) {
            NodeList cells = nodeboard.getChildNodes();
            for (int i = 0; i < cells.getLength(); i++) {
                cell = cells.item(i);

                if (cell.getNodeName().equals("cell")) {
                    if (Integer.parseInt(cell.getAttributes().getNamedItem("id").getTextContent()) == cellnodeid) {
                        return cell;
                    }
                }
            }
        }

        return null;
    }

    /**
     * Method to get the id of a cell given its node
     * @param cellnode node in xml format from which to get the id
     * @return the id of the cell
     */

    public int getIdOfCellNode(Node cellnode) {
        return Integer.parseInt(cellnode.getAttributes().getNamedItem("id").getTextContent());
    }

    /**
     * Method to get the nickname of a cell given its node
     * @param cellnode node in xml format from which to get the nickname (it can be an empty string if the cell has no nikcname)
     * @return the nickname associated to the cell
     */

    public String getNicknameOfCellNode(Node cellnode) {

        return cellnode.getAttributes().getNamedItem("nickname").getTextContent();
    }

    /**
     * Method to get the level of a cell given its node
     * @param cellnode node in xml format from which to get the level
     * @return the level of the cell
     */

    public int getLevelOfCellNode(Node cellnode) {
        return Integer.parseInt(cellnode.getAttributes().getNamedItem("level").getTextContent());
    }

    /**
     * Method to get the dome of a cell given its node
     * @param cellnode node in xml format from which to get the dome
     * @return true fi the call has a dome, otherwise false
     */

    public boolean getDomeOfCellNode(Node cellnode) {
        return Boolean.parseBoolean(cellnode.getAttributes().getNamedItem("dome").getTextContent());
    }


    /**
     * Method that sets the cellsToPrint[] with the content that it gets from the nodeboard
     * (board in xml format that this CLI has received from the server)
     */

    public void setCellsToPrint() {

        Node cell;

        if (nodeboard.hasChildNodes()) {
            NodeList cells = nodeboard.getChildNodes();

            for (int i = 0; i < cells.getLength(); i++) {
                cell = cells.item(i);

                if (cell.getNodeName().equals("cell")) {
                    int id = getIdOfCellNode(cell);
                    int level = getLevelOfCellNode(cell);
                    boolean dome = getDomeOfCellNode(cell);

                    cellsToPrint[id] = "";

                    boolean bNick = false; //used to determine if the cell is occupied by a worker
                    boolean bCandidate = false; //used to determine if the cell is a candidate cell

                    String nickname = getNicknameOfCellNode(cell);

                    if (!nickname.isEmpty()) {
                        cellsToPrint[id] += NicknameColorMap.get(nickname);
                        bNick = true;
                    }

                    if(!indexcandidatecells.isEmpty()) {
                        for(int j = 0; j < indexcandidatecells.size(); j++) {
                            if(indexcandidatecells.get(j) == id) {

                                if(nickname.isEmpty()) {
                                    cellsToPrint[id] += SANTORINI_HIGHLIGHT;
                                }
                                else {
                                    cellsToPrint[id] += NicknameHighlightMap.get(nickname);
                                }

                                bCandidate = true;
                                break;
                            }
                        }
                    }

                    if (dome) {
                        cellsToPrint[id] += COLOR_DOME + " D ";
                    } else {
                        if (level == 0) {
                            cellsToPrint[id] += " 0 ";
                        } else if (level == 1) {
                            cellsToPrint[id] += " 1 ";
                        } else if (level == 2) {
                            cellsToPrint[id] += " 2 ";
                        } else if (level == 3) {
                            cellsToPrint[id] += " 3 ";
                        }
                    }

                    if (bNick || bCandidate || dome) {
                        cellsToPrint[id] += RESET;
                    }
                }
            }
        }

        playersAndGods = "       ";

        if(NicknameGodMap.size()>0) {
            Set<String> nicknames = NicknameGodMap.keySet();
            String nickname;
            Iterator<String> itr = nicknames.iterator();

            while(itr.hasNext())
            {
                nickname = itr.next();
                if(NicknameColorMap.containsKey(nickname) && NicknameGodMap.containsKey(nickname))
                    playersAndGods += NicknameColorMap.get(nickname) + nickname + RESET + " has " + NicknameGodMap.get(nickname) + "     ";
            }
        }
    }

    public void printBoard() {

        //The BOARD is going to be printed like this
        //       ___________________
        //    E | 0 | 2 | 0 | 3 | 0 |
        //      |---+---+---+---+---|
        //    D | 0 | C | 0 | 3 | 0 |       Legend
        //      |---+---+---+---+---|       0/1/2/3 = level currently built on the cell
        //    C | C | 2 | 2 | 0 | 1 |       C = the cell has a dome
        //      |---+---+---+---+---|       colored cell = the cell is occupied by a worker of the player that has been assigned with that color
        //    B | 0 | 1 | 2 | 3 | 0 |       Player1 has Apollo, Player2 has Pan, Player3 has Athena
        //      |---+---+---+---+---|
        //    A | 1 | 1 | 0 | 3 | 0 |
        //       ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾
        //        1   2   3   4   5

        System.out.println("\n");
        System.out.println("        ___________________");
        System.out.println("    E  |" + cellsToPrint[20] + "|" + cellsToPrint[21] + "|" + cellsToPrint[22] + "|" + cellsToPrint[23] + "|" + cellsToPrint[24] + "|");
        System.out.println("       |---+---+---+---+---|");
        System.out.println("    D  |" + cellsToPrint[15] + "|" + cellsToPrint[16] + "|" + cellsToPrint[17] + "|" + cellsToPrint[18] + "|" + cellsToPrint[19] + "|       " + SANTORINI_TEXT + "Legend" + RESET);
        System.out.println("       |---+---+---+---+---|       " + TRIANGLE + " 0/1/2/3 = level currently built on the cell");
        System.out.println("    C  |" + cellsToPrint[10] + "|" + cellsToPrint[11] + "|" + cellsToPrint[12] + "|" + cellsToPrint[13] + "|" + cellsToPrint[14] + "|       " + TRIANGLE + " D = the cell has a dome");
        System.out.println("       |---+---+---+---+---|       " + TRIANGLE + " colored cell = the cell is occupied by a worker of the player that has been assigned with that color");
        System.out.println("    B  |" + cellsToPrint[5] + "|" + cellsToPrint[6] + "|" + cellsToPrint[7] + "|" + cellsToPrint[8] + "|" + cellsToPrint[9] + "|" + playersAndGods);
        System.out.println("       |---+---+---+---+---|");
        System.out.println("    A  |" + cellsToPrint[0] + "|" + cellsToPrint[1] + "|" + cellsToPrint[2] + "|" + cellsToPrint[3] + "|" + cellsToPrint[4] + "|");
        System.out.println("        ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾");
        System.out.println("         1   2   3   4   5");


    }

    /**
     * Method that resets the candidate cells saved in the CLI
     * IMPORTANT: use this each time before sending the answer to the server
     */

    public void restoreCandidateCells() {
        indexcandidatecells.clear();
    }



}